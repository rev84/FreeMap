// Generated by CoffeeScript 1.10.0
var Map, Town, Utility;

$().ready(function() {});

Map = (function() {
  function Map() {}

  Map.MAP_X = 500;

  Map.MAP_Y = 400;

  Map.TOWN_NUM = 10;

  Map.TOWN_DISTANCE_MIN = 40;

  Map.LAND_RATE = 0.5;

  Map.towns = [];

  Map.init = function() {};

  Map.drawLand = function() {
    var j, len, posAry, ref, results, x, y;
    $('#land').attr({
      width: this.MAP_X + 'px',
      height: this.MAP_Y + 'px'
    });
    posAry = this.generateLand();
    results = [];
    for (j = 0, len = posAry.length; j < len; j++) {
      ref = posAry[j], x = ref[0], y = ref[1];
      results.push($('#land').drawRect({
        strokeStyle: '#7cfc00',
        x: x,
        y: y,
        width: 1,
        height: 1
      }));
    }
    return results;
  };

  Map.drawTown = function() {
    var end, img, j, len, posAry, ref, start, x, y;
    start = Utility.militime(true);
    $('#map').css({
      width: this.MAP_X + 'px',
      height: this.MAP_Y + 'px'
    });
    posAry = this.generatePos();
    for (j = 0, len = posAry.length; j < len; j++) {
      ref = posAry[j], x = ref[0], y = ref[1];
      img = $('<img>').attr('src', './img/town.png').addClass('town').css({
        left: '' + x + 'px',
        top: '' + y + 'px'
      });
      $('#map').append(img);
    }
    end = Utility.militime(true);
    return console.log("" + (end - start) + " sec");
  };

  Map.generateLand = function() {
    var _, i, isOver, j, k, key, l, landHash, landNum, len, len1, ln, lu, lumba, lumbaNum, lumbaScale, m, minX, minY, newMapPosArray, newX, newY, o, p, parts, pos, q, r, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, res, start, t, tempLandHash, tempLandNum, tempPosStr, value, x, xPlus, y, yPlus;
    start = Utility.militime(true);
    landNum = Math.floor(this.MAP_X * this.MAP_Y * this.LAND_RATE);
    parts = [];
    for (t = j = 0; j < 5; t = ++j) {
      tempLandNum = Math.floor(landNum / 10);
      lumbaScale = 5;
      lumbaNum = 5;
      tempLandHash = {};
      lumba = [];
      for (ln = k = 0, ref = lumbaNum; 0 <= ref ? k < ref : k > ref; ln = 0 <= ref ? ++k : --k) {
        lumba.push([Math.floor(this.MAP_X / 2), Math.floor(this.MAP_Y / 2)]);
      }
      while (Utility.count(tempLandHash) < tempLandNum) {
        for (lu = l = 0, ref1 = lumba.length; 0 <= ref1 ? l < ref1 : l > ref1; lu = 0 <= ref1 ? ++l : --l) {
          newX = lumba[lu][0] + Utility.rand(-1, 1);
          newY = lumba[lu][1] + Utility.rand(-1, 1);
          if (!((0 <= newX && newX < tempLandNum - (lumbaScale - 1)) && (0 <= newY && newY < tempLandNum - (lumbaScale - 1)))) {
            continue;
          }
          lumba[lu] = [newX, newY];
          for (xPlus = m = 0, ref2 = lumbaScale; 0 <= ref2 ? m < ref2 : m > ref2; xPlus = 0 <= ref2 ? ++m : --m) {
            for (yPlus = o = 0, ref3 = lumbaScale; 0 <= ref3 ? o < ref3 : o > ref3; yPlus = 0 <= ref3 ? ++o : --o) {
              tempLandHash['' + (newX + xPlus) + '.' + (newY + yPlus)] = true;
            }
          }
        }
      }
      parts[t] = [];
      minX = this.MAP_X;
      minY = this.MAP_Y;
      for (key in tempLandHash) {
        value = tempLandHash[key];
        ref4 = key.split('.'), x = ref4[0], y = ref4[1];
        x = Number(x);
        y = Number(y);
        if (x < minX) {
          minX = x;
        }
        if (y < minY) {
          minY = y;
        }
        parts[t].push([x, y]);
      }
      for (i = p = 0, ref5 = parts[t].length; 0 <= ref5 ? p < ref5 : p > ref5; i = 0 <= ref5 ? ++p : --p) {
        parts[t][i] = [parts[t][i][0] - minX, parts[t][i][1] - minY];
      }
    }
    console.log("part:" + (Utility.militime(true) - start) + " sec");
    landHash = {};
    landHash['' + Math.floor(this.MAP_X / 2) + '.' + Math.floor(this.MAP_Y / 2)] = true;
    while (Utility.count(landHash) < landNum) {
      ref6 = Utility.randPick(landHash), tempPosStr = ref6[0], _ = ref6[1];
      ref7 = tempPosStr.split('.'), x = ref7[0], y = ref7[1];
      ref8 = [Number(x), Number(y)], x = ref8[0], y = ref8[1];
      newMapPosArray = (parts.shuffle())[0];
      ref9 = (newMapPosArray.shuffle())[0], newX = ref9[0], newY = ref9[1];
      isOver = false;
      for (q = 0, len = newMapPosArray.length; q < len; q++) {
        pos = newMapPosArray[q];
        if (!((0 <= (ref10 = x + (pos[0] - newX)) && ref10 < this.MAP_X))) {
          isOver = true;
          break;
        }
        if (!((0 <= (ref11 = y + (pos[1] - newY)) && ref11 < this.MAP_Y))) {
          isOver = true;
          break;
        }
      }
      if (isOver) {
        continue;
      }
      for (r = 0, len1 = newMapPosArray.length; r < len1; r++) {
        pos = newMapPosArray[r];
        landHash['' + (x + (pos[0] - newX)) + '.' + (y + (pos[1] - newY))] = true;
      }
    }
    res = [];
    for (key in landHash) {
      value = landHash[key];
      ref12 = key.split('.'), x = ref12[0], y = ref12[1];
      res.push([Number(x), Number(y)]);
    }
    console.log("genEnd:" + (Utility.militime(true) - start) + " sec");
    return res;
  };

  Map.generatePos = function() {
    var checkPut, j, k, posAry, randomComplete, randomPut, ref, res, rt, t;
    posAry = [];
    randomPut = (function(_this) {
      return function() {
        var flag, j, len, pickX, pickY, ref, ref1, x, y;
        ref = [Utility.rand(0, _this.MAP_X - 1), Utility.rand(0, _this.MAP_Y - 1)], pickX = ref[0], pickY = ref[1];
        flag = false;
        for (j = 0, len = posAry.length; j < len; j++) {
          ref1 = posAry[j], x = ref1[0], y = ref1[1];
          if (Math.pow(pickX - x, 2) + Math.pow(pickY - y, 2) < Math.pow(_this.TOWN_DISTANCE_MIN, 2)) {
            return false;
          }
        }
        return [pickX, pickY];
      };
    })(this);
    checkPut = (function(_this) {
      return function() {
        var canPut, j, k, l, len, m, mapAry, o, posX, posY, ref, ref1, ref2, ref3, ref4, ref5, ref6, x, y;
        mapAry = Utility.generateArray(_this.MAP_X, _this.MAP_Y, true);
        for (j = 0, len = posAry.length; j < len; j++) {
          ref = posAry[j], posX = ref[0], posY = ref[1];
          for (x = k = ref1 = posX - _this.TOWN_DISTANCE_MIN, ref2 = posX + _this.TOWN_DISTANCE_MIN; ref1 <= ref2 ? k <= ref2 : k >= ref2; x = ref1 <= ref2 ? ++k : --k) {
            if (!((0 <= x && x < _this.MAP_X))) {
              continue;
            }
            for (y = l = ref3 = posY - _this.TOWN_DISTANCE_MIN, ref4 = posY + _this.TOWN_DISTANCE_MIN; ref3 <= ref4 ? l < ref4 : l > ref4; y = ref3 <= ref4 ? ++l : --l) {
              if (!((0 <= y && y < _this.MAP_Y))) {
                continue;
              }
              if (Math.pow(posX - x, 2) + Math.pow(posY - y, 2) < Math.pow(_this.TOWN_DISTANCE_MIN, 2)) {
                mapAry[x][y] = false;
              }
            }
          }
        }
        canPut = [];
        for (x = m = 0, ref5 = mapAry.length; 0 <= ref5 ? m < ref5 : m > ref5; x = 0 <= ref5 ? ++m : --m) {
          for (y = o = 0, ref6 = mapAry[x].length; 0 <= ref6 ? o < ref6 : o > ref6; y = 0 <= ref6 ? ++o : --o) {
            if (mapAry[x][y]) {
              canPut.push([x, y]);
            }
          }
        }
        if (canPut.length === 0) {
          return false;
        }
        return canPut.shuffle().pop();
      };
    })(this);
    for (t = j = 0, ref = this.TOWN_NUM; 0 <= ref ? j < ref : j > ref; t = 0 <= ref ? ++j : --j) {
      randomComplete = false;
      for (rt = k = 0; k < 100; rt = ++k) {
        res = randomPut();
        if (res === false) {
          continue;
        }
        posAry.push(res);
        randomComplete = true;
        break;
      }
      if (randomComplete) {
        continue;
      }
      res = checkPut();
      if (res === false) {
        return false;
      }
      posAry.push(res);
    }
    return posAry;
  };

  return Map;

})();

Town = (function() {
  Town.prototype.name = null;

  function Town(posX1, posY1) {
    this.posX = posX1;
    this.posY = posY1;
  }

  Town.generateName = function() {};

  return Town;

})();

Utility = (function() {
  function Utility() {}

  Utility.generateArray = function(x, y, val) {
    var j, k, ref, ref1, res, xx, yAry, yy;
    if (y == null) {
      y = null;
    }
    if (val == null) {
      val = null;
    }
    if (y === null) {
      y = x;
    }
    res = [];
    yAry = [];
    for (yy = j = 0, ref = y; 0 <= ref ? j < ref : j > ref; yy = 0 <= ref ? ++j : --j) {
      yAry[yy] = val;
    }
    for (xx = k = 0, ref1 = x; 0 <= ref1 ? k < ref1 : k > ref1; xx = 0 <= ref1 ? ++k : --k) {
      res[xx] = yAry.concat();
    }
    return res;
  };

  Utility.militime = function(get_as_float) {
    if (get_as_float == null) {
      get_as_float = false;
    }
    return +new Date() / (get_as_float ? 1000 : 1);
  };

  Utility.rand = function(min, max) {
    Math.round();
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  Utility.count = function(object) {
    return Object.keys(object).length;
  };

  Utility.randPick = function(object) {
    var i, key, limit, value;
    limit = this.rand(0, this.count(object) - 1);
    i = 0;
    for (key in object) {
      value = object[key];
      if (i === limit) {
        return [key, value];
      }
      i++;
    }
    return false;
  };

  return Utility;

})();

Array.prototype.shuffle = function() {
  var i, n, ref;
  n = this.length;
  while (n) {
    n--;
    i = Utility.rand(0, n);
    ref = [this[n], this[i]], this[i] = ref[0], this[n] = ref[1];
  }
  return this;
};

Array.prototype.in_array = function(value) {
  var j, len, v;
  for (j = 0, len = this.length; j < len; j++) {
    v = this[j];
    if (v === value) {
      return true;
    }
  }
  return false;
};

Array.prototype.copy = function() {
  var j, k, len, len1, res, res2, v, v2;
  res = [];
  for (j = 0, len = this.length; j < len; j++) {
    v = this[j];
    res2 = [];
    for (k = 0, len1 = v.length; k < len1; k++) {
      v2 = v[k];
      res2.push(v2);
    }
    res.push(res2);
  }
  return res;
};
